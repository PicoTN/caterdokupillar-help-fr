<template>
  <v-sheet theme="dark" class="intro">
    <h1 class="margin-bottom">Caterdokupillar Help</h1>
    <!-- Image Map Generated by https://www.fla-shop.com/image-map/ -->
    <img src="@/assets/caterdokupillar.svg" usemap="#image-map">

    <map name="image-map">
      <area target="" alt="The Face of Eternity" title="The Face of Eternity" @click="showPuzzle(0)" coords="95,72,175,141" shape="rect">
      <area target="" alt="Apertif" title="Apertif" @click="showPuzzle(1)" coords="221,187,146,124,365,38" shape="rect">
    </map>  

    <p class="margin-bottom">This document is intended to assist you in completing the Caterdokupillar. Start in the top left, and as each 6x6 puzzle is completed, 4 digits will automatically carry over as givens for the next puzzle. Read the rules carefully for each puzzle, as many contain variants.</p>
    <p>Furthermore, if you get stuck on a particular puzzle, don't fret, as that's where this document comes in. It not only contains the rules for each puzzle, but most importantly, it has the digits you need for the next puzzle available for viewing.</p>
    <v-container max-width="100%">
      <v-row justify="center" wrap>
        <v-col cols="12" sm="8" md="6">
          <v-text-field
            v-model="searchQuery"
            label="Search puzzles by title, author, rules language or number"
            class="mt-4"
            clearable
          ></v-text-field>
        </v-col>
        <v-col cols="12" md="3" sm="2" class="d-flex justify-center">
          <v-btn class="mt-4" @click="openAllPanels" size="x-large">Open Selected Puzzles' Rules</v-btn>
        </v-col>
        <v-col cols="12" md="3" sm="2" class="d-flex justify-center">
          <v-btn class="mt-4" @click="closeAllPanels" size="x-large">Close All Puzzles' Rules</v-btn>
        </v-col>
      </v-row>
    </v-container>
  </v-sheet>
  <v-sheet class="d-flex flex-wrap bg-surface-variant">
    <v-sheet class="ma-2 pa-2" elevation="5" rounded="true" v-if="filteredPuzzles.length > 0" width="400" v-for="(puzzle,index) in filteredPuzzles" >
      <div style="text-align: center;">
        <h3 v-html="`${filteredPuzzles[index].highlightedIndex} ${filteredPuzzles[index].highlightedTitle}`"></h3>
        <h3 v-html="`by ${filteredPuzzles[index].highlightedAuthor}`"></h3>
      </div>
      <v-expansion-panels v-model="openPanels[filteredPuzzles[index].originalIndex]">
        <v-expansion-panel title="Rules">
          <v-expansion-panel-text>
            <div v-html="filteredPuzzles[index].highlightedRules"></div>
          </v-expansion-panel-text>
        </v-expansion-panel>
        <v-expansion-panel title="Digits">
          <v-expansion-panel-text>
            <div v-html="formatDigits(filteredPuzzles[index].digits)"></div>
          </v-expansion-panel-text>
        </v-expansion-panel>
      </v-expansion-panels>
    </v-sheet>
  </v-sheet>
</template>

<script setup>
  import { ref } from 'vue';
  import puzzles from '@/assets/caterpillar-grids.json';

  const searchQuery = ref('');
  const openPanels = ref(puzzles.map(() => [0]));
  
  // Utility function to escape special characters in a regex pattern
  function escapeRegExp(string) {
    if ( !string )
      return ''
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  function formatDigits(digits) {
    if (!digits)
      return ''
    const firstHalf = digits.slice(0, 2);
    const secondHalf = digits.slice(2, 4);

    return `${firstHalf}<br/>${secondHalf}`;
  }

  function formatRules(rules){
    return rules.replaceAll("\n","<br/>")
  }

  function rulesKey(index) {
    return `rules-${index}`
  }
  
  function digitsKey(index) {
    return `digits-${index}`
  }

  function closeAllPanels() {
    openPanels.value = openPanels.value.map((panels) => {
      return panels.filter(panel => panel !== 0);
    });
  }

  const clonedPuzzles =  puzzles.map((puzzle, index) => ({ ...puzzle, originalIndex: index }));

  const highlightMatch = (text, query) => {
    const tokens = query.toLowerCase().trim().split(/\s+/);
    if (tokens.length === 0) return text;

    tokens.forEach(token => {
      const escapedToken = escapeRegExp(token);
      const regex = new RegExp(`(${escapedToken})`, 'gi');
      text = text.replace(regex, '<mark>$1</mark>');
    });

    return text;
  };

  const filteredPuzzles = computed(() => {
    if (!searchQuery.value || !searchQuery.value.trim()) {
      return clonedPuzzles.map(puzzle => ({
        ...puzzle,
        highlightedTitle: puzzle.title,
        highlightedAuthor: puzzle.author,
        highlightedRules: formatRules(puzzle.rules),
        highlightedIndex: `${puzzle.originalIndex + 1}.`
      })).sort((a, b) => a.originalIndex - b.originalIndex);
    }

    const tokens = searchQuery.value.toLowerCase().trim().split(/\s+/);

    return clonedPuzzles
      .map(puzzle => {
        const highlightedTitle = highlightMatch(puzzle.title || '', searchQuery.value);
        const highlightedAuthor = highlightMatch(puzzle.author || '', searchQuery.value);
        const highlightedRules = highlightMatch(formatRules(puzzle.rules), searchQuery.value);
        const highlightedIndex = highlightMatch(`${puzzle.originalIndex + 1}.`, searchQuery.value);
        const highlightIndexAndTitle = highlightMatch(`${puzzle.originalIndex + 1}. ${puzzle.title}`, searchQuery.value);

        return {
          ...puzzle,
          highlightedTitle,
          highlightedAuthor,
          highlightedRules,
          highlightedIndex,
          highlightIndexAndTitle
        };
      })
      .filter(puzzle => {
        return tokens.every(token => {
          const title = puzzle.title ? puzzle.title.toLowerCase() : '';
          const author = puzzle.author ? puzzle.author.toLowerCase() : '';
          const rules = puzzle.rules ? puzzle.rules.toLowerCase() : '';
          const indexString = `${puzzle.originalIndex + 1}.`;
          const indexAndTitle = `${puzzle.originalIndex + 1}. ${puzzle.title}`.toLowerCase();

          return (
            title.includes(token) ||
            author.includes(token) ||
            rules.includes(token) ||
            indexString.includes(token) ||
            indexAndTitle.includes(token)
          );
        });
      })
      .sort((a, b) => a.originalIndex - b.originalIndex);
  });

  function openAllPanels() {
    filteredPuzzles.value.forEach(puzzle => {
      if (!openPanels.value[puzzle.originalIndex].includes(0)) {
        openPanels.value[puzzle.originalIndex].push(0);
      }
    });
  }

  function showPuzzle(puzzleIndex) {
    const puzzle = puzzles[puzzleIndex];
    searchQuery.value = `${puzzleIndex + 1}. ${puzzle.title}`;
    
    openPanels.value = { [puzzleIndex]: [0] }; // Automatically opens the rules panel
  }
</script>

<style scoped>
  .intro {
    padding: 2rem 2rem 0 2rem;
  }
  .intro h1 {
    text-align: center;
  }
  .margin-bottom {
    margin-bottom: 1.5rem;
  }
  #puzzles .v-sheet {
    background: #e0e0e0;
  }
</style>
